package goble

import (
	"log"

	"github.com/raff/goble/xpc"
)

const (
	ALL = "__allEvents__"
)

// Event generated by blued, with associated data
type Event struct {
	Name               string
	State              string
	DeviceUUID         xpc.UUID
	ServiceUuid        string
	CharacteristicUuid string
	Peripheral         Peripheral
	Data               []byte
	Mtu                int
	IsNotification     bool
}

// The event handler function.
// Return true to terminate
type EventHandlerFunc func(Event) bool
type subscriberFunc struct {
	eventName string
	fn        EventHandlerFunc
}

// Emitter is an object to emit and handle Event(s)
type Emitter struct {
	handlers  map[string]EventHandlerFunc
	event     chan Event
	subscribe chan subscriberFunc
	verbose   bool
	clean     chan bool
}

func MakeEmitter() Emitter {
	return Emitter{handlers: make(map[string]EventHandlerFunc), event: make(chan Event), subscribe: make(chan subscriberFunc), clean: make(chan bool)}
}

// Init initialize the emitter and start a goroutine to execute the event handlers
func (e *Emitter) Init() {

	// event handler
	go func() {
		for {
			select {
			case ev := <-e.event:
				if fn, ok := e.handlers[ev.Name]; ok {
					fn(ev)
				} else if fn, ok := e.handlers[ALL]; ok {
					fn(ev)
				} else {
					if e.verbose {
						log.Println("unhandled Emit", ev)
					}
				}
			case cb := <-e.subscribe:
				if cb.fn == nil {
					delete(e.handlers, cb.eventName)
				} else {
					e.handlers[cb.eventName] = cb.fn
				}
			case cleaning := <-e.clean:
				if cleaning == true {
					close(e.event)
					close(e.subscribe)
					close(e.clean)
					return
				}
			}
		}
		//close(e.event) // TOFIX: this causes new "emits" to panic.
	}()
}

func (e *Emitter) SetVerbose(v bool) {
	e.verbose = v
}

// Emit sends the event on the 'event' channel
func (e *Emitter) Emit(ev Event) {
	e.event <- ev
}

// On(event, cb) registers an handler for the specified event
func (e *Emitter) On(event string, fn EventHandlerFunc) {
	e.subscribe <- subscriberFunc{eventName: event, fn: fn}
}

func (e *Emitter) Close() {
	e.clean <- true
}
